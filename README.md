
# Lightshield

A Self-Contained Pipeline to keep a local mirror of the RiotGames API.  
Does:
- Pull regular updates on players ranks
- Update players match histories
- Save match_details and match_timeline for matches

Does not:
- Give real time updates on players
- Give per match updates on players ranks
- Work well with personal key ratelimits


## Setup

#### Generate the config file
```shell
lightshield init
```

For documentation on the config file check [here.](Config.md)

#### Setup Database

Lightshield is set up to run with one of 2 databases, PostgreSQL and CrateDB. After setting the option of which to use
in the config file execute the initial table setup script:
```shell
lightshield init-database
```


## Usage

Lightshield can temporarily be executed directly through the command line (Although requiring a few peripheral services):
```shell
lightshield run [service [ ...]]
```
This is not recommended for production environments and should be used mainly to assure proper connectivity to databases,
proxy and rabbitmq.

Alternatively Lightshield can be run through [Docker](Docker.md) or [Kubernetes (Not yet implemented)](Kubernetes.md).


## DB Structure

Lightshield generates 3 tables:

#### Ranking
Containing rankings per user and per platform unique by summonerId and platform. Because rankings don't disappear after
a user swaps server the rankings in here are also kept for multiple platforms.

The `league_ranking` service feeds into this table. The `puuid_collector` service expands the entries with a puuid.

```sql
    summoner_id  VARCHAR(63),
    platform     VARCHAR,
    puuid        VARCHAR(78),

    rank         VARCHAR,
    division     VARCHAR,
    leaguepoints SMALLINT,

    -- Ranked wins + losses
    games_sq     SMALLINT,
    games_fq     SMALLINT,

    -- Last updated value
    last_updated TIMESTAMP WITHOUT TIME ZONE
```

#### Summoner
Central table containing a summoners puuid, their last known name, their last known match played, and their last known
platform.

Entries are initially generated by the `puuid_collector` service. 

- A timestamp is used to track when the last match history update was called.
- When a user is found as a participant in a match the `last_activity` timestamp is updated.
- latest_match is updated only after match_history updates.

```sql
    puuid               VARCHAR(78),
    part                GENERATED ALWAYS AS SUBSTR(puuid, 1, 1),
    name                VARCHAR,

    -- Currently assumed platform
    platform            VARCHAR,

    -- Last time match-history was updated for the user
    last_history_update TIMESTAMP DEFAULT NULL,
    latest_match        BIGINT    DEFAULT NULL,
    -- Either through a match found or a summoner-v4 endpoint
    last_activity       TIMESTAMP WITHOUT TIME ZONE,
    -- summoner_tracker update timestamp. So it only updates every x days
    last_updated        TIMESTAMP WITHOUT TIME ZONE
```

#### Match
The match table contains basic infos on each matchId, not however the actual match details or match timeline.

Matches are added through the `match_history` service. 

- `queue` is set immediately if a specific queue is selected in config.yaml.
- Otherwise `queue, timestamp, version, duration, win` are all set based on the match_details response.


- The `details` column is set once the `match_details` service has pulled the details.
- The `timeline` column is set once the `match_timeline` service has pulled the timeline.

```sql
    match_id      BIGINT,
    platform      VARCHAR,

    queue         SMALLINT,
    "timestamp"   TIMESTAMP WITHOUT TIME ZONE,
    version       SMALLINT,
    duration      SMALLINT DEFAULT NULL,
    win           BOOLEAN  DEFAULT NULL, -- Represents the winning team (0|1)

    -- Needed to avoid excluding correct match_ids as faulty/deleted becaues they aren't found first try
    -- Retries up to 10 times
    -- On a failed try the reserved counter is not reset to avoid immediate retries on a presumed faulty ID
    find_fails    SMALLINT DEFAULT 0,
    details       BOOLEAN,
    timeline      BOOLEAN
```


### Standalone Multi-Host Ratelimiter 
Lightshield offers its ratelimiter as a standalone [python library](https://pypi.org/project/lightshield/) which only
requires the redis services included in this larger package.

For more details see [here.](Rate%20Limiting.md)